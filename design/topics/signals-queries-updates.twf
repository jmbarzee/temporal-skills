# Source: signals-queries-updates.md
# Patterns: signal/query/update declarations, watch blocks, approval flows

# --- Signal-driven order workflow ---

workflow OrderWorkflow(orderId: string) -> (OrderResult):
    signal PaymentReceived(transactionId: string, amount: decimal):
        status = "payment_received"
        lastTransactionId = transactionId

    query GetStatus() -> (string):
        return status

    query GetProgress() -> (Progress):
        return Progress{status: status, orderId: orderId}

    activity GetOrder(orderId) -> order

    status = "validating"
    activity ValidateOrder(order)

    status = "awaiting_payment"

    # Wait for payment signal with timeout
    await one:
        signal PaymentReceived:
            status = "completed"
            close OrderResult{status: "completed"}
        timer(24h):
            status = "payment_timeout"
            close failed OrderResult{status: "payment_timeout"}

# --- Approval flow with multi-target await ---

workflow ApprovalWorkflow(request: Request) -> (Decision):
    signal Approved(approver: string):
        approved = true
        approver_name = approver

    signal Rejected(approver: string, reason: string):
        rejected = true
        reject_reason = reason

    approved = false
    rejected = false
    approver_name = ""
    reject_reason = ""

    activity NotifyApprovers(request)

    # Wait for either Approved or Rejected signal, or timeout
    await one:
        signal Approved:
            close Decision{status: "approved", approver: approver_name}
        signal Rejected:
            close failed Decision{status: "rejected", reason: reject_reason}
        timer(7d):
            activity NotifyExpired(request)
            close failed Decision{status: "expired"}

# --- Batch collector with signal accumulation ---

workflow BatchCollector(batchId: string) -> (BatchResult):
    signal AddItem(item: Item):
        itemCount = itemCount + 1

    signal CompleteBatch():
        completed = true

    itemCount = 0
    completed = false

    for:
        await one:
            signal CompleteBatch:
                break
            timer(1h):
                break

    activity ProcessBatch(batchId, itemCount) -> result
    close BatchResult{itemCount: itemCount, result: result}

# --- Update-driven subscription workflow ---

workflow SubscriptionWorkflow(userId: string):
    signal Cancel():
        cancelled = true

    update ChangePlan(newPlan: string) -> (ChangeResult):
        plan = newPlan
        return ChangeResult{success: true, plan: plan}

    update AddCredits(amount: int) -> (CreditResult):
        credits = credits + amount
        return CreditResult{total: credits}

    query GetPlan() -> (string):
        return plan

    plan = "free"
    credits = 0
    cancelled = false

    for:
        await one:
            signal Cancel:
                break
            timer(30d):
                activity BillUser(userId, plan)

    close

# --- Supporting activities ---

activity GetOrder(orderId: string) -> (Order):
    return db.get(orderId)

activity ValidateOrder(order: Order):
    validate(order)

activity NotifyApprovers(request: Request):
    notify_approvers(request)

activity NotifyExpired(request: Request):
    notify_expired(request)

activity ProcessBatch(batchId: string, count: int) -> (BatchResult):
    return process(batchId, count)

activity BillUser(userId: string, plan: string):
    bill(userId, plan)
