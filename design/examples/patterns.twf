# Source: patterns.md
# Patterns: process, entity, saga, fan-out/fan-in, pipeline, state machine, polling

# --- Process Workflow ---

workflow OrderFulfillment(order: Order) -> (OrderResult):
    # Step 1: Validate
    activity ValidateOrder(order) -> validated
    if (validated.success == false):
        close failed OrderResult{status: "invalid", error: validated.error}

    # Step 2: Reserve
    activity ReserveInventory(order.items) -> reservation

    # Step 3: Charge
    activity ProcessPayment(order.payment) -> payment

    # Step 4: Fulfill
    activity ShipOrder(order, reservation)

    # Step 5: Notify
    activity SendConfirmation(order.customer)

    close OrderResult{status: "completed", trackingId: reservation.trackingId}

# --- Entity Workflow ---

workflow AccountEntity(accountId: string, state: AccountState):
    signal Deposit(amount: decimal):
        state.balance = state.balance + amount
        activity RecordTransaction(accountId, "deposit")

    signal Withdraw(amount: decimal):
        state.balance = state.balance - amount
        activity RecordTransaction(accountId, "withdraw")

    signal Close():
        activity CloseAccount(accountId)
        shouldClose = true

    query GetBalance() -> (decimal):
        return state.balance

    update Transfer(amount: decimal, toAccount: string) -> (TransferResult):
        if (state.balance < amount):
            return TransferResult{success: false, error: "insufficient funds"}
        state.balance = state.balance - amount
        activity RecordTransaction(accountId, "transfer")
        return TransferResult{success: true}

    if (state == null):
        activity LoadAccount(accountId) -> state

    eventCount = 0
    shouldClose = false

    for:
        await one:
            watch (shouldClose):
                hint signal Deposit
                hint signal Withdraw
                hint signal Close
                close
            timer (24h):
                activity DailyReconciliation(accountId)

        eventCount = eventCount + 1
        if (eventCount > 1000):
            continue_as_new(accountId, state)

# --- Saga Pattern (adapted without try/catch) ---

workflow BookingWorkflow(booking: Booking) -> (BookingResult):
    # Step 1: Reserve flight
    activity ReserveFlight(booking.flight) -> flight

    # Step 2: Reserve hotel
    activity ReserveHotel(booking.hotel) -> hotel

    # Step 3: Reserve car
    activity ReserveCar(booking.car) -> car

    # Step 4: Charge payment
    activity ChargePayment(booking.payment) -> payment

    # All succeeded
    close BookingResult{status: "confirmed"}

# --- Saga compensation workflow (called on failure) ---

workflow CompensateBooking(flight: string, hotel: string, car: string):
    # Run compensations
    activity CancelFlight(flight)
    activity CancelHotel(hotel)
    activity CancelCar(car)
    close

# --- Fan-Out/Fan-In ---

workflow BatchProcessor(items: []Item) -> (BatchResult):
    # Fan-out: start all processing in parallel
    await all:
        for (item in items):
            activity ProcessBatchItem(item) -> result

    # Fan-in: aggregate results
    activity AggregateResults(result) -> aggregated
    close BatchResult{processed: aggregated.count}

# --- Pipeline ---

workflow DataPipeline(rawData: RawData) -> (ProcessedData):
    # Stage 1: Ingest
    activity Ingest(rawData) -> ingested

    # Stage 2: Validate
    activity Validate(ingested) -> validated
    if (validated.valid == false):
        close failed ProcessedData{status: "invalid", errors: validated.errors}

    # Stage 3: Transform
    activity Transform(validated.data) -> transformed

    # Stage 4: Enrich
    activity Enrich(transformed) -> enriched

    # Stage 5: Load
    activity Load(enriched)

    close ProcessedData{status: "complete", recordCount: enriched.count}

# --- State Machine ---

workflow DocumentApproval(doc: Document) -> (ApprovalResult):
    signal Submit():
        state = "pending_review"
        activity NotifyReviewers(doc)

    signal Approve():
        state = "approved"

    signal Reject():
        state = "rejected"

    signal RequestChanges():
        state = "changes_requested"

    signal Withdraw():
        state = "withdrawn"

    state = "draft"

    for:
        switch (state):
            case "draft":
                await one:
                    watch (state):
                        hint signal Submit
                    timer (90d):
                        state = "expired"
            case "pending_review":
                await one:
                    watch (state):
                        hint signal Approve
                        hint signal Reject
                        hint signal RequestChanges
                    timer (30d):
                        state = "expired"
            case "changes_requested":
                await one:
                    watch (state):
                        hint signal Submit
                        hint signal Withdraw
                    timer (30d):
                        state = "expired"
            case "approved":
                activity PublishDocument(doc)
                close ApprovalResult{status: "approved"}
            case "rejected":
                activity ArchiveDocument(doc)
                close ApprovalResult{status: "rejected"}
            case "withdrawn":
                close ApprovalResult{status: "withdrawn"}
            case "expired":
                close ApprovalResult{status: "expired"}

# --- Polling ---

workflow WaitForResource(resourceId: string) -> (Resource):
    backoff = 5

    for:
        activity CheckResourceStatus(resourceId) -> status

        if (status.ready):
            activity GetResource(resourceId) -> resource
            close resource

        if (status.failed):
            close failed Resource{error: status.error}

        # Wait with backoff
        timer backoff
        backoff = backoff * 2

# --- Supporting activities ---

activity ValidateOrder(order: Order) -> (ValidateResult):
    return validate(order)

activity ReserveInventory(items: []Item) -> (Reservation):
    return reserve(items)

activity ProcessPayment(payment: Payment) -> (PaymentResult):
    return charge(payment)

activity ShipOrder(order: Order, reservation: Reservation):
    ship(order, reservation)

activity SendConfirmation(customer: Customer):
    notify(customer)

activity LoadAccount(accountId: string) -> (AccountState):
    return db.load(accountId)

activity RecordTransaction(accountId: string, txType: string):
    db.record(accountId, txType)

activity CloseAccount(accountId: string):
    db.close(accountId)

activity DailyReconciliation(accountId: string):
    reconcile(accountId)

activity ReserveFlight(flight: FlightSpec) -> (FlightReservation):
    return reserve(flight)

activity ReserveHotel(hotel: HotelSpec) -> (HotelReservation):
    return reserve(hotel)

activity ReserveCar(car: CarSpec) -> (CarReservation):
    return reserve(car)

activity ChargePayment(payment: Payment) -> (PaymentResult):
    return charge(payment)

activity CancelFlight(flightId: string):
    cancel(flightId)

activity CancelHotel(hotelId: string):
    cancel(hotelId)

activity CancelCar(carId: string):
    cancel(carId)

activity ProcessBatchItem(item: Item) -> (ItemResult):
    return process(item)

activity AggregateResults(results: []ItemResult) -> (AggregateResult):
    return aggregate(results)

activity Ingest(rawData: RawData) -> (IngestedData):
    return ingest(rawData)

activity Validate(data: IngestedData) -> (ValidationResult):
    return validate(data)

activity Transform(data: ValidatedData) -> (TransformedData):
    return transform(data)

activity Enrich(data: TransformedData) -> (EnrichedData):
    return enrich(data)

activity Load(data: EnrichedData):
    load(data)

activity NotifyReviewers(doc: Document):
    notify(doc.reviewers)

activity PublishDocument(doc: Document):
    publish(doc)

activity ArchiveDocument(doc: Document):
    archive(doc)

activity CheckResourceStatus(resourceId: string) -> (ResourceStatus):
    return check(resourceId)

activity GetResource(resourceId: string) -> (Resource):
    return fetch(resourceId)
