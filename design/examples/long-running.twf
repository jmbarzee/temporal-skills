# Source: long-running.md
# Patterns: continue_as_new, entity workflow, signal/query/update, signal draining

# --- Basic continue-as-new pattern ---

workflow LongRunningProcessor(state: State):
    signal NewEvent(data: EventData):
        activity ProcessEvent(state) -> result
        state.processed = state.processed + 1
        eventCount = eventCount + 1

    eventCount = 0

    for:
# REMOVED: await signal NewEvent

        # Reset history before it gets too large
        if (eventCount >= 1000):
            continue_as_new(state)

# --- Entity workflow pattern ---

workflow UserEntity(userId: string, state: UserState):
    signal UpdateProfile(data: ProfileData):
        state.profile = data
        activity PersistUser(userId, state)

    signal AddCredits(amount: decimal):
        state.credits = state.credits + amount
        activity PersistUser(userId, state)

    signal Deactivate():
        state.active = false
        activity PersistUser(userId, state)
        shouldDeactivate = true

    query GetState() -> (UserState):
        return state

    update UpdateSettings(settings: Settings) -> (Result):
        state.settings = settings
        activity PersistUser(userId, state)
        return Result{success: true}

    # Initialize state if new
    if (state == null):
        activity LoadUser(userId) -> state

    eventCount = 0
    shouldDeactivate = false

    for:
        # Wait for commands or periodic triggers
        hint signal UpdateProfile
        hint signal AddCredits
        hint signal Deactivate
        await one:
            timer 24h:
                activity DailyMaintenance(userId, state)

        if (shouldDeactivate):
            return

        eventCount = eventCount + 1

        # Continue-as-new periodically
        if (eventCount > 500):
            continue_as_new(userId, state)

# --- History management: fixed event count ---

workflow FixedCountProcessor(state: State):
    signal WorkItem(data: ItemData):
        activity DoWork(state)
        eventCount = eventCount + 1

    eventCount = 0

    for:
# REMOVED: await signal WorkItem

        if (eventCount >= 1000):
            continue_as_new(state)

# --- Signal draining before continue-as-new ---

workflow DrainingProcessor(state: State):
    signal IncomingEvent(data: EventData):
        activity ProcessDrainedEvent(state)
        count = count + 1

    count = 0

    for:
# REMOVED: await signal IncomingEvent

        if (count >= 500):
            # Drain pending signals at natural boundary
            activity FlushPending(state)
            continue_as_new(state)

# --- Supporting activities ---

activity ProcessEvent(state: State) -> (EventResult):
    return process(state)

activity LoadUser(userId: string) -> (UserState):
    return db.load(userId)

activity PersistUser(userId: string, state: UserState):
    db.save(userId, state)

activity DailyMaintenance(userId: string, state: UserState):
    run_maintenance(userId, state)

activity DoWork(state: State):
    work(state)

activity ProcessDrainedEvent(state: State):
    process(state)

activity FlushPending(state: State):
    flush(state)
