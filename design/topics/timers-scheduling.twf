# Source: timers-scheduling.md
# Patterns: timer delay, deadline, polling with backoff, periodic

# --- Basic timer: delayed notification ---

workflow DelayedNotification(userId: string, delay: duration):
    # Durable sleep - workflow pauses but state is preserved
    await timer(delay)
    activity SendNotification(userId)

# --- Deadline pattern: race between operation and timer ---

workflow ProcessWithDeadline(data: Data) -> (Result):
    await one:
        activity LongOperation(data) -> result:
            close Result{success: true, data: result}
        timer(1h):
            activity Cleanup(data)
            close failed Result{success: false, error: "deadline exceeded"}

# --- Periodic execution within workflow ---

workflow HealthMonitor(resourceId: string):
    count = 0

    for:
        activity CheckHealth(resourceId)
        await timer(5m)
        count = count + 1
        if (count > 1000):
            continue_as_new(resourceId)

# --- Polling with backoff ---

workflow WaitForResource(resourceId: string) -> (Resource):
    backoff = 1s
    maxBackoff = 60s

    for:
        activity CheckResource(resourceId) -> resource
        if (resource.ready):
            close resource

        await one:
            timer(backoff):
                backoff = min(backoff * 2, maxBackoff)
            timer(30m):
                close failed Resource{error: "timeout"}

# --- Deadline with periodic check ---

workflow WaitForCompletion(jobId: string) -> (JobResult):
    checks = 0

    for:
        activity GetJobStatus(jobId) -> status
        if (status.complete):
            close JobResult{status: "complete", data: status.data}

        checks = checks + 1
        if (checks > 100):
            close JobResult{status: "timeout"}

        await timer(30s)

# --- Polling with continue-as-new for history management ---

workflow LongPoller(resourceId: string, iteration: int) -> (Resource):
    count = 0

    for:
        activity PollResource(resourceId) -> status
        if (status.ready):
            activity FetchResource(resourceId) -> resource
            close resource

        await timer(5s)
        count = count + 1
        if (count >= 500):
            continue_as_new(resourceId, iteration + 1)

# --- Supporting activities ---

activity SendNotification(userId: string):
    send(userId)

activity LongOperation(data: Data) -> (OperationResult):
    return process(data)

activity Cleanup(data: Data):
    cleanup(data)

activity CheckHealth(resourceId: string) -> (HealthStatus):
    return check(resourceId)

activity CheckResource(resourceId: string) -> (Resource):
    return check(resourceId)

activity GetJobStatus(jobId: string) -> (JobStatus):
    return get_status(jobId)

activity PollResource(resourceId: string) -> (ResourceStatus):
    return poll(resourceId)

activity FetchResource(resourceId: string) -> (Resource):
    return fetch(resourceId)
