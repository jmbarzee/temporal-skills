# Source: signals-queries-updates.md
# Patterns: signal/query/update declarations, watch blocks, approval flows

# --- Signal-driven order workflow ---

workflow OrderWorkflow(orderId: string) -> (OrderResult):
    signal PaymentReceived(transactionId: string, amount: decimal):
        status = "processing"
        activity FulfillOrder(order)

    query GetStatus() -> (string):
        return status

    query GetProgress() -> (Progress):
        return Progress{status: status, orderId: orderId}

    activity GetOrder(orderId) -> order

    status = "validating"
    activity ValidateOrder(order)

    status = "awaiting_payment"

    # Wait for payment signal with timeout
    await one:
        watch (status):
            hint signal PaymentReceived
            if (status == "processing"):
                status = "completed"
                close OrderResult{status: "completed"}
        timer (24h):
            status = "payment_timeout"
            close failed OrderResult{status: "payment_timeout"}

# --- Approval flow with multi-target await ---

workflow ApprovalWorkflow(request: Request) -> (Decision):
    signal Approved(approver: string):
        approved = true
        approver_name = approver

    signal Rejected(approver: string, reason: string):
        rejected = true
        reject_reason = reason

    approved = false
    rejected = false
    approver_name = ""
    reject_reason = ""

    activity NotifyApprovers(request)

    # Wait for either Approved or Rejected signal, or timeout
    await one:
        watch (approved):
            hint signal Approved
            close Decision{status: "approved", approver: approver_name}
        watch (rejected):
            hint signal Rejected
            close failed Decision{status: "rejected", reason: reject_reason}
        timer (7d):
            activity NotifyExpired(request)
            close failed Decision{status: "expired"}

# --- Batch collector with signal accumulation ---

workflow BatchCollector(batchId: string) -> (Batch):
    signal AddItem(item: Item):
        items = items + 1

    signal CompleteBatch():
        completed = true

    items = 0
    completed = false

    for:
        await one:
            watch (completed):
                hint signal AddItem
                hint signal CompleteBatch
                break
            timer (1h):
                break

    activity ProcessBatch(batchId, items) -> result
    close Batch{items: items}

# --- Update-driven subscription workflow ---

workflow SubscriptionWorkflow(userId: string):
    signal Cancel():
        cancelled = true

    update ChangePlan(newPlan: string) -> (ChangeResult):
        plan = newPlan
        return ChangeResult{success: true, plan: plan}

    update AddCredits(amount: int) -> (CreditResult):
        credits = credits + amount
        return CreditResult{total: credits}

    query GetPlan() -> (string):
        return plan

    plan = "free"
    credits = 0
    cancelled = false

    for:
        await one:
            watch (cancelled):
                hint signal Cancel
                break
            timer (30d):
                activity BillUser(userId, plan)

    close

# --- Supporting activities ---

activity GetOrder(orderId: string) -> (Order):
    return db.get(orderId)

activity ValidateOrder(order: Order):
    validate(order)

activity FulfillOrder(order: Order):
    fulfill(order)

activity NotifyApprovers(request: Request):
    notify_approvers(request)

activity NotifyExpired(request: Request):
    notify_expired(request)

activity ProcessBatch(batchId: string, count: int) -> (BatchResult):
    return process(batchId, count)

activity BillUser(userId: string, plan: string):
    bill(userId, plan)
